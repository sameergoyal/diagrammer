import { Meta } from "@storybook/blocks";

<Meta title="Docs/Usage/State" />

# State

This is the interface for the Diagrammer state object. The state of the entire editor is captured within this structure and can be used to rehydrate an editor with the same state as a previous session, from the persisted state. **Please note** that Diagrammer itself doesnt provide solutions to persist this state. It provides consumers an API to fetch the graph state at any time.

Any custom data models for a consumer use case will need to be translated to the DiagrammerData model for the graph to be re-hydrated. Likewise, the model fetched from Diagrammer will be in the DiagrammerData form.

## Structure of the state object

Please note that this state object is for demonstration purposes only. The upto date state object can be found inside the bundled types after installing from NPM.

```typescript
interface DiagrammerData<NodeType, EdgeType> {
  nodes: {
    [id: string]: {
      /**
       * Unique identifier for the node.
       * Autogenerated for nodes newly created.
       * Supplied for nodes already present when diagrammer initializes.
       * In the case it is supplied, please ensure that this is unique.
       */
      id: string;
      /**
       * Type of the node. Optional.
       * References to the id present on the potential node when it was dragged in.
       * Also useful to specify override connector placements, hiding specific connectors
       * or providing the shape for boundary connector placements.
       */
      typeId?: string;
      /**
       * Contains node data managed by diagrammer.
       */
      diagrammerData: {
        /**
         * Current position of the node w.r.t the workspace
         */
        position: Position;
        /**
         * Current size of the node
         */
        size: Size;
        /**
         * Denotes whether the node is currently selected.
         */
        selected?: boolean;
        /**
         * Denotes whether the node is currently being dragged.
         */
        dragging?: boolean;
      };
      /** Contains data managed by the consumer */
      consumerData?: NodeType;
    };
  };
  edges: {
    [id: string]: {
      /**
       * Unique identifier for the edge.
       * Autogenerated for edges newly created.
       * Supplied for edges already present when diagrammer initializes.
       * In the case it is supplied, please ensure that this is unique.
       */
      id: string;
      /**
       * References the id for the node where this edge originates.
       * Leads to inconsistencies if this refers to a node that doesnt exist.
       */
      src: string;
      /**
       * References the id for the node where this edge ends.
       * Leads to inconsistencies if this refers to a node that doesnt exist.
       */
      dest: string;
      /** Contains edge data managed by diagrammer */
      diagrammerData: {
        /** Denotes whether the edge is selected */
        selected?: boolean;
      };
      /** Contains data managed by the consumer */
      consumerData?: EdgeType;
    };
  };
  panels: {
    [id: string]: {
      /**
       * Unique identifier for the panel.
       * Provided by the consumer.
       * Used for referencing the render callback.
       */
      id: string;
      /**
       * Current position of the panel in the view container.
       * Please note that panels remain outside the workspace
       * so are not affected by its scale & panning.
       */
      position: Position;
      /**
       * Current size for the panel.
       * Used for providing a container to render the panel content in.
       */
      size: Size;
      /**
       * Position Anchor. Optional. Used for docking panels.
       * When not specified, panels are assumed to be relative to Top Left corner of view container.
       * When specified, position is assumed to be relative to the anchor.
       */
      positionAnchor?: PositionAnchorType;

      /**
       * Denoted whether the panel is in undocking mode.
       * Panel is in undocking mode when it was previously docked,
       * is currently being dragged and is within the docking bounds.
       */
      undocking?: boolean;
    };
  };
  workspace: {
    /**
     * Denotes the pixel values that the workspace has been translated by on x & y axis
     */
    position: Position;
    /**
     * Denotes the scale of the workspace, where 1 denotes natural scale.
     * Smaller than 1 denotes that the workspace has been zoomed out.
     * Greater than 1 denotes that the workspace has been zoomed in.
     */
    scale: number;
    /**
     * Denotes the size of the workspace that the customer can move nodes around in.
     * Every object within the workspace, i.e. nodes, edges, potential nodes stays within these bounds.
     */
    canvasSize: Size;
    /**
     * Denotes the size of the container diagrammer is rendered in.
     * To update due to window resizing, or panels outside diagrammer shifting content,
     * call the `updateContainer` API.
     */
    viewContainerSize: Size;
  };
  editor: {
    /**
     * Current context menu state if one needs to be rendered currently.
     */
    contextMenu?: {
      /**
       * Current position of the context menu in the view container.
       * Please note context menus are not part of the workspace
       * so not affected by its scale & panning.
       */
      position: Position;
      /**
       * Type of the object that the context menu is being displayed for.
       * For example, node, edge, panel, workspace, etc.
       */
      targetType: DiagrammerComponentsType;
      /**
       * Unique identifier to identify the specific node or edge or panel.
       * Absent for the workspace.
       */
      targetId?: string;
    };
    /**
     * Current mode of the editor.
     */
    mode: EditorModeType;
    /**
     * Current selection marquee state if one needs to be rendered currently.
     */
    selectionMarquee?: {
      /**
       * Position where the user clicked to start the selection.
       * This remains one of the 4 corners of the selections marquee
       */
      anchor: Position;
      /**
       * Current position of the cursor.
       */
      position: Position;
    };
  };
  plugins?: {
    [id: string]: {
      /**
       * Current state for the plugin against its respective ID.
       */
      data: any;
    };
  };
}
```

## Accessing the State

This is covered in forthcoming section on APIs as well, but worth mentioning here. The current state can be fetched anytime from the diagrammer instance.

### Fetching the current state

```javascript
const diagrammer = new Diagrammer(container, config);
.
.
.
const currentState = diagrammer.store.getState();
```

### Listening to state updates

```javascript
const diagrammer = new Diagrammer(container, config);
diagrammer.store.subscribe(() => diagrammer.store.getState()
```
